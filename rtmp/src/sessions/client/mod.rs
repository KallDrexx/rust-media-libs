mod config;
mod errors;
mod events;
mod outstanding_transaction;
mod result;
mod state;

#[cfg(test)]
mod tests;

pub use self::events::ClientSessionEvent;
pub use self::config::ClientSessionConfig;
pub use self::result::ClientSessionResult;
pub use self::errors::{ClientSessionError, ClientSessionErrorKind};
pub use self::state::ClientState;

use self::outstanding_transaction::{OutstandingTransaction, TransactionPurpose};
use std::collections::HashMap;
use std::mem;
use std::time::SystemTime;
use bytes::Bytes;
use rml_amf0::Amf0Value;
use time::RtmpTimestamp;
use sessions::StreamMetadata;
use chunk_io::{ChunkSerializer, ChunkDeserializer, Packet};
use messages::{RtmpMessage, UserControlEventType};

type ClientResult = Result<Vec<ClientSessionResult>, ClientSessionError>;

/// A session that represents the client side of a single RTMP connection.
///
/// The `ClientSession` encapsulates the details of how a client interacts with a server.  This
/// includes how to connect to an application on the server, requesting publishing or playback,
/// and reacting to events and responses the server may send.
///
/// While RTMP connections can support multiple media operations simultanously (e.g. have 2
/// streams send video while another one pulls video) the `ClientSession` has been designed for
/// the main use case of one operation per connection.
///
/// Due to the way the header compression properties of the RTMP chunking protocol, is is required
/// that
///
/// * All bytes **after** the handshake has been completed are passed into the `ClientSession` in
/// the order they were received
/// * All responses generated by the session are sent to the server **in order**
/// * No extraneous bytes are passed into the session, and only bytes generated by the session are
/// sent to the server.
///
/// Any violation of these points have a high probability of causing RTMP chunk parsing errors
/// by either the `ClientSession` or the peer.
pub struct ClientSession {
    start_time: SystemTime,
    serializer: ChunkSerializer,
    deserializer: ChunkDeserializer,
    config: ClientSessionConfig,
    next_transaction_id: u32,
    outstanding_transactions: HashMap<u32, OutstandingTransaction>,
    current_state: ClientState,
    connected_app_name: Option<String>,
    active_stream_id: Option<u32>,
    peer_window_ack_size: Option<u32>,
    bytes_received: u64,
    bytes_received_since_last_ack: u32,
}

impl ClientSession {
    pub fn new(config: ClientSessionConfig) -> ClientSession {
        let session = ClientSession {
            start_time: SystemTime::now(),
            serializer: ChunkSerializer::new(),
            deserializer: ChunkDeserializer::new(),
            next_transaction_id: 1,
            outstanding_transactions: HashMap::new(),
            current_state: ClientState::Disconnected,
            active_stream_id: None,
            connected_app_name: None,
            peer_window_ack_size: None,
            bytes_received: 0,
            bytes_received_since_last_ack: 0,
            config,
        };

        session
    }

    pub fn handle_input(&mut self, bytes: &[u8]) -> ClientResult {
        let mut results = Vec::new();
        self.bytes_received += bytes.len() as u64;

        if let Some(peer_ack_size) = self.peer_window_ack_size {
            self.bytes_received_since_last_ack += bytes.len() as u32;
            if self.bytes_received_since_last_ack >= peer_ack_size {
                let ack_message = RtmpMessage::Acknowledgement {sequence_number: self.bytes_received_since_last_ack};
                let ack_payload = ack_message.into_message_payload(self.get_epoch(), 0)?;
                let ack_packet = self.serializer.serialize(&ack_payload, false, false)?;

                self.bytes_received_since_last_ack = 0;
                results.push(ClientSessionResult::OutboundResponse(ack_packet));
            }
        }

        let mut bytes_to_process = bytes;
        loop {
            match self.deserializer.get_next_message(bytes_to_process)? {
                None => break, // no more messages
                Some(payload) => {
                    let message = payload.to_rtmp_message()?;
                    let mut message_results = match message {
                        RtmpMessage::Acknowledgement {sequence_number}
                            => self.handle_acknowledgement(sequence_number)?,

                        RtmpMessage::Amf0Command {command_name, transaction_id, command_object, additional_arguments}
                            => self.handle_amf0_command(command_name, transaction_id, command_object, additional_arguments)?,

                        RtmpMessage::Amf0Data {values}
                            => self.handle_amf0_data(values, payload.message_stream_id)?,

                        RtmpMessage::AudioData {data}
                            => self.handle_audio_data(payload.message_stream_id, data, payload.timestamp)?,

                        RtmpMessage::VideoData {data}
                            => self.handle_video_data(payload.message_stream_id, data, payload.timestamp)?,

                        RtmpMessage::UserControl {event_type, timestamp, stream_id, buffer_length}
                            => self.handle_user_control(event_type, timestamp, stream_id, buffer_length)?,

                        RtmpMessage::WindowAcknowledgement {size}
                            => self.handle_window_ack_size(size)?,

                        _ => vec![ClientSessionResult::UnhandleableMessageReceived(payload)],
                    };

                    results.append(&mut message_results);
                    bytes_to_process = &[];
                }
            }
        }

        Ok(results)
    }

    pub fn request_connection(&mut self, app_name: String) -> Result<ClientSessionResult, ClientSessionError> {
        match self.current_state {
            ClientState::Disconnected => (),
            _ => {
                let kind = ClientSessionErrorKind::CantConnectWhileAlreadyConnected;
                return Err(ClientSessionError {kind});
            },
        }

        let transaction_id = self.get_next_transaction_id();
        let transaction = OutstandingTransaction::ConnectionRequested {app_name: app_name.clone()};
        self.outstanding_transactions.insert(transaction_id, transaction);

        let mut properties = HashMap::new();
        properties.insert("app".to_string(), Amf0Value::Utf8String(app_name));
        properties.insert("flashVer".to_string(), Amf0Value::Utf8String(self.config.flash_version.clone()));
        properties.insert("objectEncoding".to_string(), Amf0Value::Number(0.0));

        let message = RtmpMessage::Amf0Command {
            command_name: "connect".to_string(),
            command_object: Amf0Value::Object(properties),
            additional_arguments: vec![],
            transaction_id: transaction_id as f64,
        };

        let payload = message.into_message_payload(self.get_epoch(), 0)?;
        let packet = self.serializer.serialize(&payload, false, false)?;

        Ok(ClientSessionResult::OutboundResponse(packet))
    }

    pub fn request_playback(&mut self, stream_key: String) -> Result<ClientSessionResult, ClientSessionError> {
        match self.current_state {
            ClientState::Connected => (),
            _ => {
                let kind = ClientSessionErrorKind::SessionInInvalidState {current_state: self.current_state.clone()};
                return Err(ClientSessionError {kind});
            }
        }

        let transaction_id = self.get_next_transaction_id();
        let transaction = OutstandingTransaction::CreateStream {
            purpose: TransactionPurpose::PlayRequest {stream_key}
        };

        self.outstanding_transactions.insert(transaction_id, transaction);

        let message = RtmpMessage::Amf0Command {
            command_name: "createStream".to_string(),
            transaction_id: transaction_id as f64,
            command_object: Amf0Value::Null,
            additional_arguments: Vec::new(),
        };

        let payload = message.into_message_payload(self.get_epoch(), 0)?;
        let packet = self.serializer.serialize(&payload, false, false)?;

        Ok(ClientSessionResult::OutboundResponse(packet))
    }

    pub fn stop_playback(&mut self) -> ClientResult {
        // Validate we are in a state to do this
        match self.current_state {
            ClientState::Playing {..} => (),
            ClientState::PlayRequested {..} => (),
            _ => return Ok(Vec::new()), // Nothing to stop since we aren't performing playback
        }

        self.current_state = ClientState::Connected;
        match mem::replace(&mut self.active_stream_id, None) {
            None => Ok(Vec::new()), // Should never happen since we should always have a valid stream id
            Some(stream_id) => {
                let message = RtmpMessage::Amf0Command {
                    command_name: "deleteStream".to_string(),
                    transaction_id: 0.0, // always 0 per spec
                    command_object: Amf0Value::Null,
                    additional_arguments: vec![Amf0Value::Number(stream_id as f64)],
                };

                let payload = message.into_message_payload(self.get_epoch(), stream_id)?;
                let packet = self.serializer.serialize(&payload, false, false)?;
                Ok(vec![ClientSessionResult::OutboundResponse(packet)])
            }
        }
    }

    pub fn send_ping_request(&mut self) -> Result<(Packet, RtmpTimestamp), ClientSessionError> {
        let current_epoch = self.get_epoch();
        let message = RtmpMessage::UserControl {
            event_type: UserControlEventType::PingRequest,
            buffer_length: None,
            stream_id: None,
            timestamp: Some(current_epoch.clone()),
        };

        let payload = message.into_message_payload(self.get_epoch(), 0)?;
        let packet = self.serializer.serialize(&payload, false, false)?;
        Ok((packet, current_epoch))
    }

    fn handle_video_data(&self, stream_id: u32, data: Bytes, timestamp: RtmpTimestamp) -> ClientResult {
        // PlayRequested state is allowed because some servers send video data prior to the
        // `NetStream.Play.Start` command.
        match self.current_state {
            ClientState::PlayRequested {..} => (),
            ClientState::Playing {..} => (),
            _ => {
                let kind = ClientSessionErrorKind::SessionInInvalidState {current_state: self.current_state.clone()};
                return Err(ClientSessionError {kind});
            }
        }

        // Validate we are active on the stream this message came from
        match self.active_stream_id {
            None => return Ok(Vec::new()), // not active on any stream
            Some(active_stream_id) if active_stream_id != stream_id => return Ok(Vec::new()), // not active on this stream
            Some(_) => (),
        }

        let event = ClientSessionEvent::VideoDataReceived {data, timestamp};
        Ok(vec![ClientSessionResult::RaisedEvent(event)])
    }

    fn handle_audio_data(&self, stream_id: u32, data: Bytes, timestamp: RtmpTimestamp) -> ClientResult {
        // PlayRequested state is allowed because some servers send audio data prior to the
        // `NetStream.Play.Start` command.
        match self.current_state {
            ClientState::PlayRequested {..} => (),
            ClientState::Playing {..} => (),
            _ => {
                let kind = ClientSessionErrorKind::SessionInInvalidState {current_state: self.current_state.clone()};
                return Err(ClientSessionError {kind});
            }
        }

        // Validate we are active on the stream this message came from
        match self.active_stream_id {
            None => return Ok(Vec::new()), // not active on any stream
            Some(active_stream_id) if active_stream_id != stream_id => return Ok(Vec::new()), // not active on this stream
            Some(_) => (),
        }

        let event = ClientSessionEvent::AudioDataReceived {data, timestamp};
        Ok(vec![ClientSessionResult::RaisedEvent(event)])
    }

    fn handle_amf0_data(&mut self, mut data: Vec<Amf0Value>, stream_id: u32) -> ClientResult {
        if data.len() == 0 {
            // No data so just do nothing
            return Ok(Vec::new());
        }

        // Validate we are active on the stream this message came from
        match self.active_stream_id {
            None => return Ok(Vec::new()), // not active on any stream
            Some(active_stream_id) if active_stream_id != stream_id => return Ok(Vec::new()), // not active on this stream
            Some(_) => (),
        }

        let first_element = data.remove(0);
        match first_element {
            Amf0Value::Utf8String(ref value) if value == "onMetaData"
                => self.handle_amf0_data_on_meta_data(data),

            _ => Ok(Vec::new()),
        }
    }

    fn handle_amf0_command(&mut self,
                           name: String,
                           transaction_id: f64,
                           command_object: Amf0Value,
                           additional_args: Vec<Amf0Value>) -> ClientResult {
        match name.as_str() {
            "_result" => self.handle_amf0_command_success_result(transaction_id, command_object, additional_args),
            "_error" => self.handle_amf0_command_failed_result(transaction_id, command_object, additional_args),
            "onStatus" => self.handle_on_status_command(additional_args),

            _ => {
                let event = ClientSessionEvent::UnhandleableAmf0Command {
                    command_name: name,
                    additional_values: additional_args,
                    command_object,
                    transaction_id,
                };

                Ok(vec![ClientSessionResult::RaisedEvent(event)])
            }
        }
    }

    fn handle_amf0_command_failed_result(&mut self,
                                         transaction_id: f64,
                                         command_object: Amf0Value,
                                         mut additional_args: Vec<Amf0Value>) -> ClientResult {
        let outstanding_transaction = match self.outstanding_transactions.remove(&(transaction_id as u32)) {
            Some(transaction) => transaction,
            None => {
                let event = ClientSessionEvent::UnknownTransactionResultReceived {
                    additional_values: additional_args,
                    command_object,
                    transaction_id,
                };

                return Ok(vec![ClientSessionResult::RaisedEvent(event)]);
            },
        };

        match outstanding_transaction {
            OutstandingTransaction::ConnectionRequested {app_name: _} => {
                let description = if additional_args.len() > 0 {
                    if let Amf0Value::Object(mut properties) = additional_args.remove(0) {
                        if let Some(Amf0Value::Utf8String(value)) = properties.remove("description") {
                            value
                        } else {
                            "".to_string()
                        }
                    } else {
                        "".to_string()
                    }
                } else {
                    "".to_string()
                };

                let event = ClientSessionEvent::ConnectionRequestRejected {description};
                Ok(vec![ClientSessionResult::RaisedEvent(event)])
            },

            OutstandingTransaction::CreateStream {purpose: _} => {
                let kind = ClientSessionErrorKind::CreateStreamFailed;
                return Err(ClientSessionError {kind});
            }
        }
    }

    fn handle_amf0_command_success_result(&mut self,
                                          transaction_id: f64,
                                          command_object: Amf0Value,
                                          additional_args: Vec<Amf0Value>) -> ClientResult {
        let outstanding_transaction = match self.outstanding_transactions.remove(&(transaction_id as u32)) {
            Some(transaction) => transaction,
            None => {
                let event = ClientSessionEvent::UnknownTransactionResultReceived {
                    additional_values: additional_args,
                    command_object,
                    transaction_id,
                };

                return Ok(vec![ClientSessionResult::RaisedEvent(event)]);
            },
        };

        match outstanding_transaction {
            OutstandingTransaction::ConnectionRequested {app_name} => {
                self.current_state = ClientState::Connected;
                self.connected_app_name = Some(app_name);

                let message = RtmpMessage::WindowAcknowledgement {size: self.config.window_ack_size};
                let payload = message.into_message_payload(self.get_epoch(), 0)?;
                let packet = self.serializer.serialize(&payload, false, false)?;
                let event = ClientSessionEvent::ConnectionRequestAccepted;
                Ok(vec![
                    ClientSessionResult::OutboundResponse(packet),
                    ClientSessionResult::RaisedEvent(event)],
                )
            },

            OutstandingTransaction::CreateStream {purpose: TransactionPurpose::PlayRequest {stream_key}} => {
                if additional_args.len() == 0 {
                    let kind = ClientSessionErrorKind::CreateStreamResponseHadNoStreamNumber;
                    return Err(ClientSessionError {kind})
                }

                let stream_id = match additional_args[0] {
                    Amf0Value::Number(number) => number as u32,
                    _ => {
                        let kind = ClientSessionErrorKind::CreateStreamResponseHadNoStreamNumber;
                        return Err(ClientSessionError {kind})
                    }
                };

                self.active_stream_id = Some(stream_id);
                self.current_state = ClientState::PlayRequested {stream_key: stream_key.clone()};

                let buffer_message = RtmpMessage::UserControl {
                    event_type: UserControlEventType::SetBufferLength,
                    buffer_length: Some(self.config.playback_buffer_length_ms),
                    stream_id: Some(stream_id),
                    timestamp: None,
                };

                let buffer_payload = buffer_message.into_message_payload(self.get_epoch(), 0)?;
                let buffer_packet = self.serializer.serialize(&buffer_payload, false, false)?;

                let play_message = RtmpMessage::Amf0Command {
                    command_name: "play".to_string(),
                    transaction_id: 0.0,
                    command_object: Amf0Value::Null,
                    additional_arguments: vec![Amf0Value::Utf8String(stream_key)]
                };

                let play_payload = play_message.into_message_payload(self.get_epoch(), stream_id)?;
                let play_packet = self.serializer.serialize(&play_payload, false, false)?;

                Ok(vec![
                    ClientSessionResult::OutboundResponse(buffer_packet),
                    ClientSessionResult::OutboundResponse(play_packet),
                ])
            }
        }
    }

    fn handle_on_status_command(&mut self, mut arguments: Vec<Amf0Value>) -> ClientResult {
        if arguments.len() < 1 {
            let kind = ClientSessionErrorKind::InvalidOnStatusArguments;
            return Err(ClientSessionError {kind});
        }

        let mut properties = match arguments.remove(0) {
            Amf0Value::Object(properties) => properties,
            _ => {
                let kind = ClientSessionErrorKind::InvalidOnStatusArguments;
                return Err(ClientSessionError {kind});
            }
        };

        let code = match properties.remove("code") {
            Some(Amf0Value::Utf8String(code)) => code,

            _ => {
                let kind = ClientSessionErrorKind::InvalidOnStatusArguments;
                return Err(ClientSessionError {kind});
            }
        };

        match code.as_ref() {
            "NetStream.Play.Start" => self.handle_play_start(),

            x => {
                let event = ClientSessionEvent::UnhandleableOnStatusCode {code: x.to_string()};
                Ok(vec![ClientSessionResult::RaisedEvent(event)])
            }
        }
    }

    fn handle_play_start(&mut self) -> ClientResult {
        let stream_key = match self.current_state {
            ClientState::PlayRequested {ref stream_key} => stream_key.clone(),
            _ => {
                let kind = ClientSessionErrorKind::SessionInInvalidState {current_state: self.current_state.clone()};
                return Err(ClientSessionError {kind});
            },
        };

        self.current_state = ClientState::Playing {stream_key: stream_key.clone()};

        let event = ClientSessionEvent::PlaybackRequestAccepted {stream_key};
        Ok(vec![ClientSessionResult::RaisedEvent(event)])
    }

    fn handle_amf0_data_on_meta_data(&mut self, mut data: Vec<Amf0Value>) -> ClientResult {
        if data.len() < 1 {
            // No data so ignore it
            return Ok(Vec::new());
        }

        let properties = match data.remove(0) {
            Amf0Value::Object(properties) => properties,
            _ => return Ok(Vec::new()), // malformed so ignore it
        };

        let mut metadata = StreamMetadata::new();
        metadata.apply_metadata_values(properties);

        let event = ClientSessionEvent::StreamMetadataReceived {metadata};
        Ok(vec![ClientSessionResult::RaisedEvent(event)])
    }

    fn handle_acknowledgement(&mut self, sequence_number: u32) -> ClientResult {
        let event = ClientSessionEvent::AcknowledgementReceived {bytes_received: sequence_number};
        Ok(vec![ClientSessionResult::RaisedEvent(event)])
    }

    fn handle_window_ack_size(&mut self, size: u32) -> ClientResult {
        self.peer_window_ack_size = Some(size);
        Ok(Vec::new())
    }

    fn handle_user_control(&mut self,
                           event_type: UserControlEventType,
                           timestamp: Option<RtmpTimestamp>,
                           _stream_id: Option<u32>,
                           _buffer_length: Option<u32>) -> ClientResult {
        match event_type {
            UserControlEventType::PingRequest => self.handle_ping_request(timestamp),
            UserControlEventType::PingResponse => self.handle_ping_response(timestamp),
            _ => Ok(Vec::new()),
        }
    }

    fn handle_ping_request(&mut self, timestamp: Option<RtmpTimestamp>) -> ClientResult {
        let message = RtmpMessage::UserControl {
            event_type: UserControlEventType::PingResponse,
            buffer_length: None,
            stream_id: None,
            timestamp,
        };

        let payload = message.into_message_payload(self.get_epoch(), 0)?;
        let packet = self.serializer.serialize(&payload, false, false)?;
        Ok(vec![ClientSessionResult::OutboundResponse(packet)])
    }

    fn handle_ping_response(&mut self, timestamp: Option<RtmpTimestamp>) -> ClientResult {
        let timestamp = timestamp.unwrap_or(RtmpTimestamp::new(0));
        let event = ClientSessionEvent::PingResponseReceived {timestamp};
        Ok(vec![ClientSessionResult::RaisedEvent(event)])
    }

    fn get_epoch(&self) -> RtmpTimestamp {
        match self.start_time.elapsed() {
            Ok(duration) => {
                let milliseconds = (duration.as_secs() * 1000) + (duration.subsec_nanos() as u64 / 1_000_000);

                // Casting to u32 should auto-wrap the value as expected.  If not a stream will probably
                // break after 49 days but testing shows it should wrap
                RtmpTimestamp::new(milliseconds as u32)
            },

            Err(_) => RtmpTimestamp::new(0), // Time went backwards, so just consider time as at epoch
        }
    }

    fn get_next_transaction_id(&mut self) -> u32 {
        let transaction_id = self.next_transaction_id;
        self.next_transaction_id += 1;
        transaction_id
    }
}
